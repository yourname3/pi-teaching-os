#include "trapframe.h"

#include <kern/lib.h>
#include <kern/devices/interrupt_controller.h>
#include <kern/task/task.h>
#include <arch/spl.h>

/* For other decoders of the ESR register, see:
 * https://github.com/google/aarch64-esr-decoder/blob/main/src/esr/mod.rs
 */

void
aarch64_irq(struct trapframe *tf) {
    /* In the case of IRQs, we simply defer to whatever interrupt controller
     * driver is currently setup. */
    intc_dev->handle();
}

void
aarch64_trapentry(struct trapframe *tf) {
    /* When we reach the trapentry, the processor has turned off interrupts for
     * us. We need to represent this in our curtask value. */
    int oldspl = curtask->spl;
    curtask->spl = 1;
    curspl = 1;
    //printk("aarch64_trapentry\n");

    /* Last two bits indicate interrupt type. This is just a consequence of
     * how we set up the t able in interrupt.S -- we chose the numbers 0-15
     * as our vector_id values. */
    switch(tf->vector_id & 3) {
        /* 0 -- Synchronous exception -- handle an error. */
        case 0: printk("Synchronous"); break;
        /* 1 -- IRQ.
         * As per https://developer.arm.com/documentation/102412/0103/Exception-types/Asynchronous-exceptions,
         * IRQs are not errors but are simply generated by peripherals. As such,
         * pass all IRQ handling to a separate function. */
        case 1: aarch64_irq(tf); goto done;
        /* 2 -- FIQ.
         * FIQ stands for Fast IRQ. They should in general "just" be IRQs that
         * are meant to be handled faster. Our kernel is not that fast, just
         * deer to _irq as well. */
        case 2: aarch64_irq(tf); goto done;
        /* 3 -- SError.
         * SError (System Error) is an unexpected error condition. We may want
         * to just crash on these cases. */
        case 3: printk("SError"); break;
    }
    printk(": ");

    /* Similar setup to https://github.com/bztsrc/raspi3-tutorial/blob/master/11_exceptions/exc.c for now */

    uint64_t type = (tf->esr >> 26);
    switch(type) {
        case 0b000000: printk("Unknown"); break;
        case 0b000001: printk("Trapped WFI/WFE"); break;
        case 0b001110: printk("Illegal execution"); break;
        case 0b010101: printk("System call"); break;
        case 0b100000: printk("Instruction abort, lower EL"); break;
        case 0b100001: printk("Instruction abort, same EL"); break;
        case 0b100010: printk("Instruction alignment fault"); break;
        case 0b100100: printk("Data abort, lower EL"); break;
        case 0b100101: printk("Data abort, same EL"); break;
        case 0b100110: printk("Stack alignment fault"); break;
        case 0b101100: printk("Floating point"); break;
        default: printk("Unknown"); break;
    }

    if(type == 0b100100 || type == 0b100101) {
        printk(", ");
        switch((tf->esr >> 2) & 3) {
            case 0: printk("Address size fault"); break;
            case 1: printk("Translation fault"); break;
            case 2: printk("Access flag fault"); break;
            case 3: printk("Permission fault"); break;
        }
        printk(" at level %d", (tf->esr & 3));
    }
    else {
        printk(" ");
    }
    
    printk("\n\nESR = %p\n", tf->esr);

    printk("\nESR_EL1 = %p ELR_EL1 = %p\nSPSR_EL1 = %p FAR_EL1 = %p",
        tf->esr, tf->elr, tf->spsr, tf->far);

    /* For now: Hang.
     * TODO: shutdown? call another function in between...? */
    for(;;) { }

done:
    /* Restore interrupt state in curtask. 
     *
     * Note that interrupts are not actually off yet. But that is OK -- it
     * is the same logic as in spl0(). */
    curtask->spl = oldspl;
    curspl = oldspl;
}